---
title: "Script Rotten Tomatoes variables"
author: "Sofia Villamil"
date: "2024-06-01"
output: html_document
---

ROTTEN TOMATOES SCRIPT

```{r}
rm(list = ls())
```

```{r}
user_agents <- c(
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0",
  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0"
)
```

```{r}
# Function to get a random user agent
get_random_user_agent <- function() {
  sample(user_agents, 1)
}
```

### Libraries

```{r}
library(rvest)
library(httr)
library(dplyr)
library(tidyr)
library(readr)
library(future.apply) # parallel processing
```

```{r}
data <- read_csv("C:/Users/sofia/Documents/Documentos/Master Computational Social Sciences/TFM/Master Thesis/Data/movies_final_dataset_test_with_bm_cleaned.csv",show_col_types = FALSE)

colnames(data)[7] <- "release_year"
```

### URL function to take into account all the different possibilities in the links

```{r}
# Helper function to safely extract single text elements
extract_single_text <- function(node) {
  if (length(node) == 0) {
    return(NA)
  } else {
    return(html_text(node, trim = TRUE))
  }
}

# Function to generate Rotten Tomatoes URL from movie title
generate_movie_url <- function(movie_title, release_year = NULL, known_variation = NULL) {
  if (!is.null(known_variation)) {
    formatted_title <- known_variation
  } else {
    movie_title <- gsub("&", "and", movie_title)
    movie_title <- gsub("[\\$']", "", movie_title)
    formatted_title <- tolower(gsub("[ :.,!?\"-/]", "_", movie_title))
    formatted_title <- gsub("\\.\\.\\.", "_", formatted_title)
    formatted_title <- gsub("__+", "_", formatted_title)
    formatted_title <- gsub("_$", "", formatted_title)
  }
  base_url <- paste0("https://www.rottentomatoes.com/m/", formatted_title)
  is_url_valid <- function(url) {
    tryCatch({
      httr::HEAD(url)$status_code == 200
    }, error = function(e) {
      FALSE
    })
  }
  if (!is.null(release_year)) {
    movie_url_with_year <- paste0(base_url, "_", release_year)
    if (is_url_valid(movie_url_with_year)) {
      return(movie_url_with_year)
    }
  }
  if (is_url_valid(base_url)) {
    return(base_url)
  }
  years <- 2010:2024
  possible_urls <- paste0(base_url, "_", years)
  valid_urls <- possible_urls[sapply(possible_urls, is_url_valid)]
  if (length(valid_urls) > 0) {
    return(tail(valid_urls, 1))
  }
  return(NA)
}

```

### Scrapping function

```{r}
# Scrapping function
scrape_rotten_tomatoes <- function(title, release_year = NULL, known_variation = NULL) {
  cat(sprintf("Scraping Rotten data for movie title: %s\n", title))
  movie_url <- generate_movie_url(title, release_year, known_variation)
  if (is.na(movie_url)) {
    cat(sprintf("No valid URL found for: %s\n", title))
    return(data.frame(
      title_rt = title,
      critics_score_rt = NA,
      total_critics_reviews_rt = NA,
      audience_score_rt = NA,
      total_audience_reviews_rt = NA,
      top_critic_review_1_rt = NA,
      top_critic_review_2_rt = NA,
      audience_review_1_rt = NA,
      audience_review_2_rt = NA
    ))
  }

  Sys.sleep(runif(1, min = 5, max = 10))  # Random sleep between 5 and 10 seconds
  cat(sprintf("Trying URL: %s\n", movie_url))
  movie_page <- tryCatch({
    read_html(httr::GET(movie_url, httr::add_headers(`User-Agent` = get_random_user_agent())))
  }, error = function(e) {
    cat("Error in fetching movie page:", e$message, "\n")
    return(NULL)
  })

  if (is.null(movie_page)) {
    return(data.frame(
      title_rt = title,
      critics_score_rt = NA,
      total_critics_reviews_rt = NA,
      audience_score_rt = NA,
      total_audience_reviews_rt = NA,
      top_critic_review_1_rt = NA,
      top_critic_review_2_rt = NA,
      audience_review_1_rt = NA,
      audience_review_2_rt = NA
    ))
  }
  data_scrap <- tryCatch({
    title_rt <- extract_single_text(movie_page %>% html_node(xpath = '//h1[@slot="titleIntro"]//span'))
    critics_score_rt <- movie_page %>%
      html_node(xpath = '//rt-button[@slot="criticsScore"]//rt-text') %>%
      html_text(trim = TRUE) %>%
      gsub("%", "", .) %>%
      as.numeric()
    total_critics_reviews_rt <- movie_page %>%
      html_node(xpath = '//rt-link[@slot="criticsReviews" and @size="0.75"]') %>%
      html_text(trim = TRUE) %>%
      gsub("\\s+Reviews", "", .) %>%
      gsub(",", "", .) %>%
      as.numeric()
    audience_score_rt <- movie_page %>%
      html_node(xpath = '//rt-button[@slot="audienceScore"]//rt-text') %>%
      html_text(trim = TRUE) %>%
      gsub("%", "", .) %>%
      as.numeric()
    total_audience_reviews_rt <- movie_page %>%
      html_node(xpath = '//rt-link[@slot="audienceReviews" and @size="0.75"]') %>%
      html_text(trim = TRUE) %>%
      gsub("[^0-9]", "", .) %>%
      as.numeric()
    top_critic_review_1_rt <- extract_single_text(movie_page %>% 
      html_node(xpath = '(//carousel-slider//review-card-critic[@slot="tile"])[1]//rt-text[@slot="content"]'))
    top_critic_review_2_rt <- extract_single_text(movie_page %>% 
      html_node(xpath = '(//carousel-slider//review-card-critic[@slot="tile"])[2]//rt-text[@slot="content"]'))
    audience_review_1_rt <- extract_single_text(movie_page %>% 
      html_node(xpath = '(//carousel-slider//review-card-audience[@slot="tile"])[1]//rt-text[@slot="content"]'))
    audience_review_2_rt <- extract_single_text(movie_page %>% 
      html_node(xpath = '(//carousel-slider//review-card-audience[@slot="tile"])[2]//rt-text[@slot="content"]'))
    data.frame(
      title_rt = title_rt,
      Title = title_rt,
      critics_score_rt = critics_score_rt,
      total_critics_reviews_rt = total_critics_reviews_rt,
      audience_score_rt = audience_score_rt,
      total_audience_reviews_rt = total_audience_reviews_rt,
      top_critic_review_1_rt = top_critic_review_1_rt,
      top_critic_review_2_rt = top_critic_review_2_rt,
      audience_review_1_rt = audience_review_1_rt,
      audience_review_2_rt = audience_review_2_rt,
      stringsAsFactors = FALSE
    )
  }, error = function(e) {
    cat("Error in extracting data:", e$message, "\n")
    return(data.frame(
      title_rt = title,
      critics_score_rt = NA,
      total_critics_reviews_rt = NA,
      audience_score_rt = NA,
      total_audience_reviews_rt = NA,
      top_critic_review_1_rt = NA,
      top_critic_review_2_rt = NA,
      audience_review_1_rt = NA,
      audience_review_2_rt = NA
    ))
  })
  return(data_scrap)
}

```

```{r}
# Known variations for specific movies
known_variations <- list(
  "The Avengers" = "marvels_the_avengers",
  "Star Wars: The Force Awakens" = "star_wars_episode_vii_the_force_awakens",
  "Once Upon a Time… in Hollywood" = "once_upon_a_time_in_hollywood",
  "Birdman or (The Unexpected Virtue of Ignorance)" = "birdman_2014",
  "Men in Black 3" = "men_in_black_iii",
  "Kung Fu Panda 2" = "kung_fu_panda_the_kaboom_of_doom",
  "Pokémon Detective Pikachu" = "pokemon_detective_pikachu",
  "The Man from U.N.C.L.E." = "the_man_from_uncle",
  "The 5th Wave" = "the_fifth_wave",
  "G.I. Joe: Retaliation" = "gi_joe_retaliation",
  "Les Misérables" = "les_miserables",
  "The Adjustment Bureau" = "adjustment_bureau",
  "Gangster Squad" = "gangster_squad_2012",
  "R.I.P.D." = "ripd",
  "A Silent Voice: The Movie" = "a_silent_voice",
  "The Woman in Black" = "the_woman_in_black_2011",
  "The Wolf of Wall Street" = "the_wolf_of_wall_street_2013",
  "The SpongeBob Movie: Sponge Out of Water" = "the_spongebob_movie_sponge_out_of_water"
)

# Create a reversion map to revert known variations to their original titles
reversion_map <- c(
  "Marvel's the Avengers" = "The Avengers"
)

# Example data set to try small number of movies then change to the data
test_movies <- data
# Use parallel processing for scraping
plan(multisession, workers = 7) # Adjust the number of workers based on your CPU, I have 8 so I put one less

# Scrape data for each movie in the data set using parallel processing
scraped_data_list <- future_lapply(seq_len(nrow(test_movies)), function(i) {
  scrape_rotten_tomatoes(test_movies$title[i], test_movies$release_year[i], known_variations[[test_movies$title[i]]])
}, future.seed = TRUE)  

# Combining the results into a single data frame
scraped_data <- bind_rows(scraped_data_list)

# Revert known variations to their original titles
scraped_data <- scraped_data %>%
  mutate(title_rt = ifelse(title_rt %in% names(reversion_map), reversion_map[title_rt], title_rt))

# Join the scraped data back to the original test_movies data
final_data2 <- left_join(test_movies, scraped_data, by = c("title" = "title_rt"))
 
```

```{r}
# Save merged data set
write_csv(final_data2, "C:/Users/sofia/Documents/Documentos/Master Computational Social Sciences/TFM/Master Thesis/Data/movies_test_dataset_with_rotten_tomatoes_cleaned.csv")

```

 
